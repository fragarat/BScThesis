\chapter{$\vert$ Python code}
\label{chap:appa}

\section*{First synthetic experiment}
\label{sec:fse}

\begin{lstlisting}[language=Python, caption=First synthetic experiment]
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#############################################################
################### SYNTHETIC EXPERIMENT 1 ##################
#############################################################

########################## MODULES ##########################

import numpy as np
from scipy.integrate import solve_ivp
from scipy.linalg import logm
import matplotlib.pyplot as plt

######################### VARIABLES #########################
# number of nodes
N = 31 
# alpha and beta parameters
a = 0.7
b = 0.1
# depth of binary tree (2 even and 2 odd)
levels = 2
# identity matrix
I = np.eye(N) 

######################### FUNCTIONS #########################

def unirandom(matrix):
    '''
    Introduces a 1 in a uniform randomized number of entries, specified by the 
    parameter 'num_entries' in a given matrix.

            Parameters:
                    matrix (arr): matrix of size MxN

            Returns:
                    -
    '''
    # number of entries to randomize, uniform dist. with avg.= 5
    num_entries = int(np.random.uniform(low=0, high=10))
    
    if matrix.size < num_entries:
        raise ValueError("Invalid number of entries to randomize")
        
    # randomly select num_entries unique positions in the matrix
    positions = np.random.choice(matrix.size, size=num_entries, replace=False)
    # set the selected positions to 1
    matrix.flat[positions] = 1.

def A_even():
    '''
    Returns the constant value that takes A(t) at even time intervals with 
    some noise added by 'unirandom' function.

            Parameters:
                    -

            Returns:
                    ematrix (arr): NxN matrix for even time intervals
    '''
    ematrix = np.zeros((N, N))
    for i in (2**k for k in range(0, levels*2 , 2)):
        for j in range(1, i+1):
            ematrix[i-1][i*2-1] = 1
            ematrix[i-1][i*2] = 1
            i = i + 1
    unirandom(ematrix)
    return ematrix

def A_odd():
    '''
    Returns the constant value that takes A(t) at odd time intervals with 
    some noise added by 'unirandom' function.

            Parameters:
                    -

            Returns:
                    omatrix (arr): NxN matrix for odd time intervals
    '''
    omatrix = np.zeros((N, N))
    for i in (2**k for k in range(1, levels*2 , 2)):
        for j in range(1, i+1):
            omatrix[i-1][i*2-1] = 1
            omatrix[i-1][i*2] = 1
            i = i + 1
    unirandom(omatrix)
    return omatrix
   
def aggregate_out_degree(matrix):
    '''
    Returns the row sums that represent the aggregate out degree for each
    node (row) given an adjacency matrix.

            Parameters:
                    matrix (arr): adjacency matrix of size NxN

            Returns:
                    row_sums (list): list of agg. out degree for each node
    '''
    row_sums = [sum(row) for row in matrix]
    
    return row_sums


######################### A(t) #########################

# time interval t=[0, 20], with A(t) constant over each subinterval [i, i + 1)
# where A(t) = A_even and A(t) = A_odd when 'i' is even and odd respectively

A0 = A_even()
A1 = A_odd()
A2 = A_even()
A3 = A_odd()
A4 = A_even()
A5 = A_odd()
A6 = A_even()
A7 = A_odd()
A8 = A_even()
A9 = A_odd()
A10 = A_even()
A11 = A_odd()
A12 = A_even()
A13 = A_odd()
A14 = A_even()
A15 = A_odd()
A16 = A_even()
A17 = A_odd()
A18 = A_even()
A19 = A_odd()
A20 = np.zeros((N, N))

w0, v0 = eig(A0)
w1, v1 = eig(A1)
w2, v2 = eig(A2)
w3, v3 = eig(A3)
w4, v4 = eig(A4)
w5, v5 = eig(A5)
w6, v6 = eig(A6)
w7, v7 = eig(A7)
w8, v8 = eig(A8)
w9, v9 = eig(A9)
w10, v10 = eig(A10)
w11, v11 = eig(A11)
w12, v12 = eig(A12)
w13, v13 = eig(A13)
w14, v14 = eig(A14)
w15, v15 = eig(A15)
w16, v16 = eig(A16)
w17, v17 = eig(A17)
w18, v18 = eig(A18)
w19, v19 = eig(A19)

print("w0 =", w0)
print("w1 =", w1)
print("w2 =", w2)
print("w3 =", w3)
print("w4 =", w4)
print("w5 =", w5)
print("w6 =", w6)
print("w7 =", w7)
print("w8 =", w8)
print("w9 =", w9)
print("w10 =", w10)
print("w11 =", w11)
print("w12 =", w12)
print("w13 =", w13)
print("w14 =", w14)
print("w15 =", w15)
print("w16 =", w16)
print("w17 =", w17)
print("w18 =", w18)
print("w19 =", w19)

# aggregate matrix to compute the agg. out degree
agg_matrix = A0 + A1 + A2 + A3 + A4 + A5 + A6 + A7 + A8 + A9 + A10 +\
             A11 + A12 + A13 + A14 +A15 + A16 + A17 + A18 + A19
      

# Adjacency matrix for t=[0,20]
def Adj(t):
    if 0.0 <= t < 1.0:
        return A0
    if 1.0 <= t < 2.0:
        return A1
    if 2.0 <= t < 3.0:
        return A2
    if 3.0 <= t < 4.0:
        return A3
    if 4.0 <= t < 5.0:
        return A4
    if 5.0 <= t < 6.0:
        return A5
    if 6.0 <= t < 7.0:
        return A6
    if 7.0 <= t < 8.0:
        return A7
    if 8.0 <= t < 9.0:
        return A8
    if 9.0 <= t < 10.0:
        return A9
    if 10.0 <= t < 11.0:
        return A10
    if 11.0 <= t < 12.0:
        return A11
    if 12.0 <= t < 13.0:
        return A12
    if 13.0 <= t < 14.0:
        return A13
    if 14.0 <= t < 15.0:
        return A14
    if 15.0 <= t < 16.0:
        return A15
    if 16.0 <= t < 17.0:
        return A16
    if 17.0 <= t < 18.0:
        return A17
    if 18.0 <= t < 19.0:
        return A18
    if 19.0 <= t <= 20.0:
        return A19
    return A20
    
######################### ODE #########################

# Matrix ODE function in vector form
def f(t, U):
    
    # Reshape U from vector to matrix
    U = U.reshape((N, N))
    
    # Compute the matrix ODE
    dUdt = -b * (U - I) - U @ logm(I - a * Adj(t))
    
    # Reshape dUdt from matrix to vector
    dUdt = dUdt.flatten()
    return dUdt


# Initial condition 
U0 = np.eye(N)
U0 = U0.flatten()
#time span
t_span = (0, 20)

# Solve the matrix ODE numerically using Runge-Kutta 45 method
sol = solve_ivp(f, t_span, U0, method='RK45')

# Print the solution at discrete time points
print("\nsol_t :\n", sol.t)
print("\nsol_y :\n", sol.y)

# Communicability matrix U at t = 20 (entries >= 0)
U_t_20 = np.abs(sol.y[:,-1].reshape(N,N))

# broadcast centrality at t = 20
b_t_20 = U_t_20 @ np.ones(N)

# aggregate out degree 
out_degree_list = aggregate_out_degree(agg_matrix)

print("\nb(t=20) :\n", b_t_20)
print("\nAgg. out degree =", out_degree_list)

######################### PLOTS #########################

fig, ax = plt.subplots()
ax.plot(list(range(1,N+1)), b_t_20, '*')
ax.set_title(r"First synthetic experiment: $\alpha=0.7$ $\beta=0.1$")
ax.set_xlabel("node")
ax.set_ylabel("dynamic broadcast  b(t=20)")

fig.savefig('exp1_bt20.eps', format='eps')

fig2, ax2 = plt.subplots()
ax2.plot(list(range(1,N+1)), out_degree_list, '*', color='r')
ax2.set_title("First synthetic experiment")
ax2.set_xlabel("node")
ax2.set_ylabel("aggregate out degree")

fig2.savefig('exp1_agg_out_degree.eps', format='eps')
\end{lstlisting}

\section*{Second synthetic experiment}
\label{sec:sse}

\begin{lstlisting}[language=Python, caption=Second synthetic experiment]
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#############################################################
################### SYNTHETIC EXPERIMENT 2 ##################
#############################################################

########################## MODULES ##########################

import numpy as np
from scipy.integrate import solve_ivp
from scipy.linalg import logm
import matplotlib.pyplot as plt

######################## VARIABLES #####################
# number of nodes
N = 17 
# alpha and beta parameters
a = 0.9
b = 0.1

######################### A(t) #########################

# identity matrix of size NxN
I = np.eye(N) 

# A(ti) for each interval where
# ti := [(i − 1)τ , (i − 1 + 0.9)τ ), for i = 0, 1, . . . , 7, and τ = 0.1
# over the full interval t = [0, 3.5]

A0 = np.zeros((N, N)) # intercycle value, no connections

A1 = np.zeros((N, N))
A1[0][2] = 1
A1[2][0] = 1
A1[1][16] = 1
A1[16][1] = 1

A2 = np.zeros((N, N))
A2[2][3] = 1
A2[3][2] = 1

A3 = np.zeros((N, N))
A3[2][4] = 1
A3[4][2] = 1
A3[3][5] = 1
A3[5][3] = 1

A4 = np.zeros((N, N))
A4[0][16] = 1
A4[16][0] = 1
A4[1][2] = 1
A4[2][1] = 1
A4[6][3] = 1
A4[3][6] = 1
A4[4][7] = 1
A4[7][4] = 1
A4[5][9] = 1
A4[9][5] = 1

A5 = np.zeros((N, N))
A5[4][8] = 1
A5[8][4] = 1
A5[5][10] = 1
A5[10][5] = 1
A5[6][11] = 1
A5[11][6] = 1
A5[7][13] = 1
A5[13][7] = 1

A6 = np.zeros((N, N))
A6[6][12] = 1
A6[12][6] = 1
A6[7][14] = 1
A6[14][7] = 1
A6[8][15] = 1
A6[15][8] = 1

A7 = np.zeros((N, N))
A7[8][16] = 1
A7[16][8] = 1    

# Adjacency matrix during five cycles
def Adj(t):
    if 0.0 <= t < 0.09:
        return A1
    if 0.1 <= t < 0.19:
        return A2
    if 0.2 <= t < 0.29:
        return A3
    if 0.3 <= t < 0.39:
        return A4
    if 0.4 <= t < 0.49:
        return A5
    if 0.5 <= t < 0.59:
        return A6
    if 0.6 <= t < 0.69:
        return A7
    
    if 0.8 <= t < 0.89:
        return A1
    if 0.9 <= t < 0.99:
        return A2
    if 1.0 <= t < 1.09:
        return A3
    if 1.1 <= t < 1.19:
        return A4
    if 1.2 <= t < 1.29:
        return A5
    if 1.3 <= t < 1.39:
        return A6
    if 1.4 <= t < 1.49:
        return A7
    
    if 1.6 <= t < 1.69:
        return A1
    if 1.7 <= t < 1.79:
        return A2
    if 1.8 <= t < 1.89:
        return A3
    if 1.9 <= t < 1.99:
        return A4
    if 2.0 <= t < 2.09:
        return A5
    if 2.1 <= t < 2.19:
        return A6
    if 2.2 <= t < 2.29:
        return A7
    
    if 2.4 <= t < 2.49:
        return A1
    if 2.5 <= t < 2.59:
        return A2
    if 2.6 <= t < 2.69:
        return A3
    if 2.7 <= t < 2.79:
        return A4
    if 2.8 <= t < 2.89:
        return A5
    if 2.9 <= t < 2.99:
        return A6
    if 3.0 <= t < 3.09:
        return A7
    
    if 3.2 <= t < 3.29:
        return A1
    if 3.3 <= t < 3.39:
        return A2
    if 3.4 <= t < 3.49:
        return A3
    if 3.5 <= t < 3.59:
        return A4
    if 3.6 <= t < 3.69:
        return A5
    if 3.7 <= t < 3.79:
        return A6
    if 3.8 <= t < 3.89:
        return A7
    
    return A0
    
######################### ODE #########################
    
# Matrix ODE function in vector form
def f(t, U):
    
    # Reshape U from vector to matrix
    U = U.reshape((N, N))
    
    # Compute the matrix ODE
    dUdt = -b * (U - I) - U @ logm(I - a * Adj(t))
    # Reshape dUdt from matrix to vector
    dUdt = dUdt.flatten()
    return dUdt


# Initial condition 
U0 = np.eye(N)
U0 = U0.flatten()
# time span
t_span = (0, 3.5) # time span

# Solve the matrix ODE numerically using solve_ivp
sol = solve_ivp(f, t_span, U0)

# Print the solution at discrete time points
print("\nsol_t :\n", sol.t)
print("\nsol_y :\n", sol.y)

# broadcast centrality of nodes A (node 0) and B (node 1)
b_t_A = [(np.abs(sol.y[:,i].reshape(N,N)) @ np.ones(N))[0] for i in range(0,sol.y.shape[1])]
b_t_B = [(np.abs(sol.y[:,i].reshape(N,N)) @ np.ones(N))[1] for i in range(0,sol.y.shape[1])]

print("\nb(t)_A :\n", b_t_A)
print("\nb(t)_B :\n", b_t_B)

######################### PLOT #########################
    
fig, ax = plt.subplots()
ax.plot(sol.t, b_t_A, 'r', sol.t, b_t_B, 'b--')
ax.set_title(r"Second synthetic experiment: $\alpha=0.9$, $\beta=0.1$")
ax.set_xlabel("time (s)")
ax.set_ylabel("broadcast centrality  b(t)")
ax.legend(["b(t) of node A", "b(t) of node B"])
#ax.grid()
ax.set_xlim(0, 3.5)
ax.set_ylim(1, None)

fig.savefig('exp2_btA_vs_btB.eps', format='eps')
\end{lstlisting}

\section*{Voice call experiment}
\label{sec:vce}

\begin{lstlisting}[language=Python, caption=Second synthetic experiment]
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#############################################################
################### VOICE CALL EXPERIMENT  ##################
#############################################################

########################## MODULES ##########################

import numpy as np
from scipy.integrate import solve_ivp
#from scipy.linalg import logm
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import pandas as pd
from itertools import combinations
import time

######################## VARIABLES #####################
# number of nodes
N = 400 
# alpha and beta parameters
a = 1E-4
b = 1.2E-5
# identity matrix of size NxN
I = np.eye(N)

# Path to the csv file
csv_file_path = "CellPhoneCallRecords.csv"

# Max. call time duration in seconds
t_max = 3000

################### FUNCTIONS #################

def sort_indexes(arr):
    '''
    Returns array indexes sorted in descending order from max value to min
    value.

            Parameters:
                    arr (arr): array to be sorted

            Returns:
                    sorted_indexes (arr): sorted array of indexes
    '''
    sorted_indexes = sorted(range(len(arr)), key=lambda i: arr[i], reverse=True)
    return sorted_indexes

def symmetric_sum(matrix):
    '''
    Returns resulting matrix from the sum of symmetric elements of a matrix.

            Parameters:
                    matrix (arr): NxN array 

            Returns:
                    res (arr): NxN array with sum of symmetric entries 
    '''
    n = len(matrix)
    res = np.zeros((n,n))
    for i in range(n):
        for j in range(i, n):
            if i == j:
                res[i][j] = matrix[i][j]
            else:
                res[i][j] = matrix[i][j] + matrix[j][i]
                res[j][i] = res[i][j]
    return res

#################### logm approx. #####################

def logm_approx(A, a=a):
    '''
    Returns the approximation of the function logm by truncation to the 
    fifth power of its series expansion.

            Parameters:
                    A (arr): NxN array 
                    a (float): parameter

            Returns:
                    principal matrix logarithm approximation 
    '''
    A2 = A @ A
    A3 = A2 @ A
    A4 = A3 @ A
    A5 = A4 @ A
    
    return a * A - (a**2/2) * A2 + (a**3/3) * A3 - (a**4/4) * A4 + (a**5/5) * A5
    
        
#### Dynamic communicability of key nodes ####

def dyncomm_key_nodes(U):
    
    # Calculate the sum and average of all entries except the main diagonal
    total_sum = np.sum(U) - np.sum(np.diag(U))
    total_avg = total_sum / (N*N - N)
    
    # key nodes indexes
    nodes = [1, 2, 3, 5, 200]
    
    # All pairwise combinations
    pairs = list(combinations(nodes, 2))
    
    # key nodes sum
    key_sum = 0
    for item in pairs:
        key_sum += U[item[0]][item[1]]
        key_sum += U[item[1]][item[0]] 
        
    # key nodes average
    key_sum_avg = key_sum / (len(pairs) * 2)
    
    if total_avg == 0:
        return 0
    
    return key_sum_avg / total_avg


################### AGGREGATE BANDWIDTH #################
# bandwidth of a node is defined as the aggregate time call duration in which 
# this node is active over a certain period 

# Read the csv file into a Pandas DataFrame
df = pd.read_csv(csv_file_path)

# Convert the Datetime field to a datetime object
df["Datetime"] = pd.to_datetime(df["Datetime"], format="%Y%m%d %H%M")

# Filter the data for days 1 to 10
start_date = pd.Timestamp(2006, 6, 1)
end_date = pd.Timestamp(2006, 6, 10, 23, 59, 59)

df = df[(df["Datetime"] >= start_date) & (df["Datetime"] <= end_date)]

# Group the data by 'From' and 'To' fields and sum the call durations
grouped = df.groupby(["From", "To"])["Duration(seconds)"].sum()

# Initialize the matrix for call time duration for each node with zeros
agg_matrix = np.zeros((N, N))

# Update the matrix entries with the sum of call durations
for (from_cell, to_cell), duration in grouped.items():
    agg_matrix[from_cell][to_cell] = duration

# sum symmetric elements (node as sender or receiver)  
agg_matrix = symmetric_sum(agg_matrix)

# aggregate vector with the bandwidth of each node from day 1 to 10
agg_day1_to_10 = [np.sum(row) for row in agg_matrix]

print("agg_day1_to_10: (first ten elem.): \n", agg_day1_to_10[0:10])

######################### A(t) #########################

# Read the csv file into a Pandas DataFrame
df = pd.read_csv(csv_file_path)

# Convert the Datetime field to a datetime object
df["Datetime"] = pd.to_datetime(df["Datetime"], format="%Y%m%d %H%M")

def Adj(t):
    '''
    Returns the adjacency matrix of the network at a given time 't'. 
    Sets elements to 1 if 't' belongs to the datetime conversation which nodes
    are given in the .csv file by the fields 'From' and 'To'.

            Parameters:
                    t (float): time

            Returns:
                    A (arr): NxN adjacency matrix
    '''
    
    # Filter all datetimes in the interval actual time - max calltime duration
    actual_time = t0_datetime + pd.Timedelta(seconds=t)
    start_time = actual_time - pd.Timedelta(seconds=t_max)
    
    filtered = df[(df["Datetime"] >= start_time) & (df["Datetime"] <= actual_time)]

    # Initialize the adjacency matrix with zeros
    A = np.zeros((N, N))

    # Set matrix entries to 1 if the time is inside a conversation
    for index, row in filtered.iterrows():
        from_cell = row["From"]
        to_cell = row["To"]
        start_call_time = row["Datetime"]
        end_call_time = start_call_time + pd.Timedelta(seconds=row["Duration(seconds)"])
        if end_call_time >= actual_time:
            A[from_cell][to_cell] = 1
            A[to_cell][from_cell] = 1

    return A

######################## Alternative Adj(t)#####################

# Read the csv file into a Pandas DataFrame
#df = pd.read_csv(csv_file_path)

# Convert the Datetime field to a datetime object
#df["Datetime"] = pd.to_datetime(df["Datetime"], format="%Y%m%d %H%M")

# Extract the start and end time of each call
#df['start_call'] = df['Datetime']
#df['end_call'] = df['Datetime'] + pd.to_timedelta(df['Duration(seconds)'], unit='s')

def Adj2(t): 

    # Filter the dataframe to keep only the active calls at time 't'
    actual_time = t0_datetime + timedelta(seconds=t)
    active_calls = df[(actual_time >= df['start_call']) & (actual_time <= df['end_call'])]

    # Create the adjacency matrix
    A = np.zeros((N, N))
    for _, row in active_calls.iterrows():
        A[row['From'], row['To']] = 1
        A[row['To'], row['From']] = 1

    return A

######################### ODE #########################
    
# Matrix ODE function in vector form
def f(t, U):
    
    # Reshape U from vector to matrix
    U = U.reshape((N, N))
    
    # Compute the matrix ODE
    dUdt = -b * (U - I) - U @ logm_approx(Adj(t))
    # Reshape dUdt from matrix to vector
    dUdt = dUdt.flatten()
    return dUdt

######################### day 1 to 7 broadcast #########################

start_time = time.time()

# Initial condition 
U0 = np.eye(N)
U0 = U0.flatten()

# Time interval 
t0_datetime = pd.Timestamp(2006, 6, 1)
tf_datetime = pd.Timestamp(2006, 6, 6, 23, 59 ,59)
delta = tf_datetime - t0_datetime

# Time span
t0 = 0
tf = delta.total_seconds() 
t_span = (t0, tf) 

# Solve the matrix ODE numerically using solve_ivp
sol = solve_ivp(f, t_span, U0, method='RK23', rtol=1e-4, atol=1e-4)

# Print the solution at discrete time points
#print("\nsol_t :\n", sol.t)
#print("\nsol_y :\n", sol.y)

# Communicability matrix U at t=tf (day 7)
U_t_7 = np.abs(sol.y[:,-1].reshape(N,N))

# broadcast centrality at t = tf (day 7)
b_t_7 = U_t_7 @ np.ones(N)

print("\nb(t='day 7') :\n", b_t_7)

print("\nb_t_day7[1] =", b_t_7[1])
print("b_t_day7[2] =", b_t_7[2])
print("b_t_day7[3] =", b_t_7[3])
print("b_t_day7[5] =", b_t_7[5])
print("b_t_day7[200] =", b_t_7[200])

#print("\nsorted_b_indexes(t='day 7') : ",sort_indexes(b_t_7)[0:5])

# receive centrality at t = tf (day 7)
r_t_7 = U_t_7.T @ np.ones(N)

print("\nBroadcast from day 1 - 7 done!")

end_time = time.time()
total_time = end_time - start_time

print("Time taken:", round(total_time, 2), "seconds")

######################## day 7 to 10 broadcast #########################

start_time = time.time()

# Initial condition 
U0 = np.eye(N)
U0 = U0.flatten()

# Time interval
t0_datetime = pd.Timestamp(2006, 6, 7)
tf_datetime = pd.Timestamp(2006, 6, 10, 23, 59, 59)
delta = tf_datetime - t0_datetime 

# Time span
t0 = 0
tf = delta.total_seconds()
t_span = (t0, tf) 

# Solve the matrix ODE numerically using solve_ivp
sol = solve_ivp(f, t_span, U0, method='RK23', rtol=1e-4, atol=1e-4)

# Print the solution at discrete time points
#print("\nsol_t :\n", sol.t)
#print("\nsol_y :\n", sol.y)

# Communicability matrix U at t=tf (day 10)
U_t_10 = np.abs(sol.y[:,-1].reshape(N,N))

# broadcast centrality at t = tf (day 10)
b_t_10 = U_t_10 @ np.ones(N)

print("\nb(t='day 10') :\n", b_t_10)

print("\nb_t_day10[309] =", b_t_10[309])
print("b_t_day10[392] =", b_t_10[392])
print("b_t_day10[360] =", b_t_10[360])
print("b_t_day10[306] =", b_t_10[306])
print("b_t_day10[300] =", b_t_10[300])

#print("\nsorted_b_indexes(t='day 10') : ",sort_indexes(b_t_10)[0:5])

# Receive centrality at t = tf (day 10)
r_t_10 = U_t_10.T @ np.ones(N)

print("\nBroadcast from day 7 - 10 done!")

end_time = time.time()
total_time = end_time - start_time

print("Time taken:", round(total_time, 2), "seconds")

######################### PLOTS #########################

fig, ax = plt.subplots(figsize=(10,8))
ax.plot(agg_day1_to_10, b_t_7, '+', color='blue', label="rest of nodes")
ax.plot(agg_day1_to_10[200], b_t_7[200], 'v', color='red', label="ring leader ID before day 7")
ax.plot(agg_day1_to_10[1], b_t_7[1], 's', color='red', label="key nodes IDs before day 7")
ax.plot(agg_day1_to_10[2], b_t_7[2], 's', color='red') 
ax.plot(agg_day1_to_10[3], b_t_7[3], 's', color='red') 
ax.plot(agg_day1_to_10[5], b_t_7[5], 's', color='red')
ax.plot(agg_day1_to_10[300], b_t_7[300], '^', color='green', label="ring leader ID after day 7")
ax.plot(agg_day1_to_10[309], b_t_7[309], 'd', color='green', label="key nodes IDs after day 7")
ax.plot(agg_day1_to_10[392], b_t_7[392], 'd', color='green') 
ax.plot(agg_day1_to_10[360], b_t_7[360], 'd', color='green') 
ax.plot(agg_day1_to_10[306], b_t_7[306], 'd', color='green')
ax.set_title("Voice call experiment")
ax.set_xlabel("bandwidth")
ax.set_ylabel("broadcast centrality at day 7")
ax.ticklabel_format(axis="x", style="sci", scilimits=(0,0))
ax.set_xlim(0, 3.5e5)
ax.legend()

fig.savefig('voicecall_exp_1_7.eps', format='eps')

fig2, ax2 = plt.subplots(figsize=(10,8))
ax2.plot(agg_day1_to_10, b_t_10, '+', color='blue', label="rest of nodes")
ax2.plot(agg_day1_to_10[200], b_t_10[200], 'v', color='red', label="ring leader ID before day 7")
ax2.plot(agg_day1_to_10[1], b_t_10[1], 's', color='red', label="key nodes IDs before day 7")
ax2.plot(agg_day1_to_10[2], b_t_10[2], 's', color='red') 
ax2.plot(agg_day1_to_10[3], b_t_10[3], 's', color='red') 
ax2.plot(agg_day1_to_10[5], b_t_10[5], 's', color='red')
ax2.plot(agg_day1_to_10[300], b_t_10[300], '^', color='green', label="ring leader ID after day 7") 
ax2.plot(agg_day1_to_10[309], b_t_10[309], 'd', color='green', label="key nodes IDs after day 7")
ax2.plot(agg_day1_to_10[392], b_t_10[392], 'd', color='green') 
ax2.plot(agg_day1_to_10[360], b_t_10[360], 'd', color='green') 
ax2.plot(agg_day1_to_10[306], b_t_10[306], 'd', color='green')
ax2.set_title("Voice call experiment")
ax2.set_xlabel("bandwidth")
ax2.set_ylabel("broadcast centrality at day 10 (from day 7)")
ax2.ticklabel_format(axis="x", style="sci", scilimits=(0,0))
ax2.set_xlim(0, 3.5e5)
ax2.legend()

fig2.savefig('voicecall_exp_7_10.eps', format='eps')

######################### day 1 to 10 broadcast #########################

# Initial condition 
U0 = np.eye(N)
U0 = U0.flatten()

# Time interval 
t0_datetime = pd.Timestamp(2006, 6, 1)
tf_datetime = pd.Timestamp(2006, 6, 11)
delta = tf_datetime - t0_datetime

# Time span
t0 = 0
tf = delta.total_seconds() 
t_span = (t0, tf) 

# Solve the matrix ODE numerically using solve_ivp
sol = solve_ivp(f, t_span, U0, method='RK45', atol=1e-4, rtol=1e-4)

# dynamic communicability vector
comm_1_10 = np.zeros(sol.y.shape[1])

for i in range(sol.y.shape[1]):
    comm_1_10[i] = dyncomm_key_nodes(sol.y[:,i].reshape(N,N))
    
    
# No communication in the first 8 min, removing zero communicability
# Boolean mask indicating which elements are close to zero
mask = np.isclose(comm_1_10, 0, atol=1e-5)

# Filtered communicability array using the mask
filtered_comm = comm_1_10[~mask]

# Array without the close-to-zero elements
comm_1_10 = filtered_comm[np.nonzero(filtered_comm)]
sol.t = sol.t[np.nonzero(filtered_comm)]

print("communicability vector: \n", comm_1_10)

###### PLOT ######

fig3, ax3 = plt.subplots(figsize=(10,8))
x_label = np.arange(1, 11)
ax3.plot(np.linspace(1, 11, num = len(comm_1_10)), comm_1_10, color='red')
ax3.set_xlim(1, 11)
ax3.set_ylim(0, None)
ax3.set_xlabel("time")
ax3.set_ylabel("communicability between key nodes")
ax3.set_xticks(x_label)
ax3.set_xticklabels(['Day {}'.format(i) for i in x_label])
ax3.axvline(x=8, linestyle='--', color='gray', linewidth=0.8)

fig3.savefig('voicecall_exp_dyncomm.eps', format='eps')
\end{lstlisting}